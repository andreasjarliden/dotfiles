snippet cammel "camelCase to SCREAMING_SNAKE_CASE"
${1:fooBar} ${1/(([a-z])([A-Z]))|./(?1:\u$2_$3:\U$0\E)/g}
endsnippet

snippet eonce "ESP include guard"
#ifndef INCLUDE_ESP_${1:PACKAGE}_${2:FILE}_H
#define INCLUDE_ESP_$1_$2_H

$0

#endif // INCLUDE_ESP_$1_$2_H
endsnippet

snippet inc "#include "
#include <$0>
endsnippet

snippet einc "#include "
#include <esp/$0.h>
endsnippet

snippet incer "#include <esp/reconstruction/...>"
#include <esp/reconstruction/$0.h>
endsnippet

snippet incec "#include <esp/calibration/...>"
#include <esp/calibration/$0.h>
endsnippet

snippet inccu "#include <esp/cuda/...>"
#include <esp/cuda/$0.h>
endsnippet

snippet coutvar "cout << foo: << foo << endl"
std::cout << "${1:Expression}: " << $1 << std::endl;
endsnippet

snippet mv "makeVector(..)"
makeVector($0
endsnippet

snippet v3i "Vector3i"
Vector3i 
endsnippet

snippet v3f "Vector3f"
Vector3f 
endsnippet

snippet v3d "Vector3d"
Vector3d 
endsnippet

snippet v2i "Vector2i"
Vector2i 
endsnippet

snippet v2f "Vector2f"
Vector2f 
endsnippet

snippet v2d "Vector2d"
Vector2d 
endsnippet

snippet ns "namespace { }"
namespace ${1:name} {
$0
} // namespace $1
endsnippet

snippet ans "anonymous namespace"
namespace {
$0
} // unnamed namespace
endsnippet

snippet ens "namespace esp { }"
namespace esp {
$0
} // namespace esp
endsnippet

snippet uns "using namespace"
using namespace 
endsnippet

snippet tf "TestCase member function"
void ${1:Class}::test$2(TestResult& result, TestContext&) const {
  $0
}
endsnippet

snippet tsh "TestSuite header"
#ifndef INCLUDED_ESPTEST_${2/.*/\U$0\E/}_${1/(([a-z])([A-Z]))|./(?1:\u$2_$3:\U$0\E)/g}_TEST_H
#define INCLUDED_ESPTEST_${2/.*/\U$0\E/}_${1/(([a-z])([A-Z]))|./(?1:\u$2_$3:\U$0\E)/g}_TEST_H

#include <esptest/${2:`!v expand("%:h:t")`}/export.h>
#include <esp/util/TestSuite.h>

namespace esp {
class TestResult;
class TestContext;
}

namespace esptest {

ESP_PUBLIC class ESPTEST_${2/.*/\U$0\E/}_EXPORT ${1:`!v expand("%:t:r")`}: public esp::TestSuite {
  typedef $1 Self;

  void test1(esp::TestResult&, esp::TestContext&) const;$0

public:
  $1();
};

} // esptest namespace

#endif // INCLUDED_ESPTEST_${2/.*/\U$0\E/}_${1/(([a-z])([A-Z]))|./(?1:\u$2_$3:\U$0\E)/g}_TEST_H
endsnippet

snippet tsi "TestSuite implementation"
#include <esptest/${2:`!v expand("%:h:t")`}/$1.h>
#include <esp/$2/${1/(.*)Test/$1/}.h>
#include <esp/util/TestResult.h>
#include <esp/util/TestCaseMemberFunction.h>

using namespace esp;

namespace esptest {

void ${1:`!v expand("%:t:r")`}::test1(TestResult& result, TestContext&) const {
  result.failed("not implemented");
}

$1::$1()
  : TestSuite("esp-test-$2-${1/(.*)Test/\L$1\E/}", "") {
  typedef TestCaseMemberFunction<Self> TC;

  addTest(make_shared<TC>(this, &Self::test1, "esp-test-$2-${1/(.*)Test/\L$1\E/}-1", "test1"));
}

} // namespace esptest

endsnippet

snippet sp "shared_ptr"
shared_ptr<$1>$0
endsnippet

snippet cout "std::cout << ... << std::endl"
std::cout << $0 << std::endl;
endsnippet

snippet endl "std::endl"
<< std::endl;
endsnippet
